import pygame
import random
import math

# --- 1. Initialization and Constants ---
pygame.init()

# Screen dimensions
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Advanced PyFishing")

# Colors
WHITE = (255, 255, 255)
BLUE_LIGHT = (135, 206, 235)  # Sky
BLUE_DARK = (0, 0, 100)        # Deep Water
YELLOW = (255, 255, 0)         # Bobber
RED = (255, 0, 0)              # Reeling Indicator
GREEN = (0, 200, 0)            # Success

# Game Constants
FPS = 60
BOBBER_SIZE = 10
LINE_THICKNESS = 2
REEL_SPEED = 5
MAX_REEL_STRENGTH = 100
FISH_PULL_BASE = 0.5
FISH_PULL_VARIANCE = 0.3

# Game States
CASTING = 0
WAITING = 1
REELING = 2
GAME_OVER = 3

# --- 2. Game Objects (Classes) ---

class Player:
    def __init__(self):
        self.score = 0
        self.rod_strength = 100
        self.reel_meter = 0 # Current strength being applied

    def add_score(self, points):
        self.score += points

class Bobber:
    def __init__(self, start_pos):
        self.x, self.y = start_pos
        self.is_cast = False
        self.target_y = SCREEN_HEIGHT * 0.8 # Water level
        self.speed = 15 # Casting speed
        self.splash_time = 0
        self.splash_duration = 30 # Frames

    def cast(self, target_x):
        self.x = 100 # Player position
        self.y = SCREEN_HEIGHT * 0.1 # Start high
        self.target_x = target_x
        self.is_cast = True
        self.casting_distance = abs(self.target_x - self.x)
        self.casting_progress = 0

    def update_casting(self):
        if self.is_cast:
            # Simple parabolic arc simulation
            self.casting_progress += 0.05
            t = self.casting_progress
            
            # X position moves linearly
            self.x = 100 + t * (self.target_x - 100) / 2
            
            # Y position (parabola)
            height = 100 # Max height of the arc
            self.y = SCREEN_HEIGHT * 0.1 + (t * (self.target_y - SCREEN_HEIGHT * 0.1) - t * t * height) / 2.5
            
            if self.y >= self.target_y:
                self.y = self.target_y
                self.is_cast = False
                self.splash_time = self.splash_duration
                return WAITING
        return CASTING

    def update_waiting(self):
        # Bobbing animation
        self.y = self.target_y + math.sin(pygame.time.get_ticks() * 0.005) * 5
        # Splash decay
        if self.splash_time > 0:
            self.splash_time -= 1

    def draw(self, surface):
        # Draw fishing line from player (approx 100, 100) to bobber
        pygame.draw.line(surface, WHITE, (100, 100), (self.x, self.y), LINE_THICKNESS)
        
        # Draw bobber
        if self.splash_time > 0:
            # Draw splash rings
            radius = (self.splash_duration - self.splash_time) * 2
            alpha = max(0, 255 - (self.splash_duration - self.splash_time) * 10)
            splash_color = (255, 255, 255, alpha)
            
            s = pygame.Surface((radius * 2, radius * 2), pygame.SRCALPHA)
            pygame.draw.circle(s, splash_color, (radius, radius), radius, 1)
            surface.blit(s, (self.x - radius, self.y - radius))

        pygame.draw.circle(surface, YELLOW, (int(self.x), int(self.y)), BOBBER_SIZE)

class Fish:
    def __init__(self):
        self.caught = False
        # Fish size affects difficulty and points
        self.size = random.uniform(5.0, 30.0) # In cm
        self.points = int(self.size * 10)
        self.pull_strength = FISH_PULL_BASE + self.size * 0.05 + random.uniform(-FISH_PULL_VARIANCE, FISH_PULL_VARIANCE)
        self.pull_strength = max(0.2, self.pull_strength) # Minimum pull

    def get_pull(self):
        # Fish pull varies sinusoidally to make reeling harder
        # The smaller the size, the faster the variation (twitchy)
        frequency = 0.01 + 1.0 / self.size
        return self.pull_strength * (1 + math.sin(pygame.time.get_ticks() * frequency)) * 0.5

    def get_name(self):
        if self.size < 10:
            return "Small Minnow"
        elif self.size < 20:
            return "Lake Trout"
        else:
            return "Giant Bass"

# --- 3. Game Logic Functions ---

def draw_water(surface):
    # Sky
    surface.fill(BLUE_LIGHT)
    
    # Water surface (Horizon line)
    water_level = SCREEN_HEIGHT * 0.7
    pygame.draw.rect(surface, (0, 150, 255), (0, water_level, SCREEN_WIDTH, SCREEN_HEIGHT - water_level))
    
    # Deep water effect
    for i in range(1, 10):
        depth_color = (0, 0, 100 + i * 15) # Gets darker with depth
        pygame.draw.rect(surface, depth_color, (0, water_level + i * 30, SCREEN_WIDTH, 30))

def draw_hud(surface, player, game_state, bobber):
    font = pygame.font.Font(None, 36)
    
    # Score
    score_text = font.render(f"Score: {player.score}", True, WHITE)
    surface.blit(score_text, (10, 10))
    
    # State Indicator
    state_names = ["CASTING", "WAITING", "REELING", "GAME OVER"]
    state_color = WHITE
    if game_state == WAITING:
        state_color = YELLOW
    elif game_state == REELING:
        state_color = RED
    
    state_text = font.render(f"State: {state_names[game_state]}", True, state_color)
    surface.blit(state_text, (SCREEN_WIDTH - 200, 10))

    if game_state == REELING:
        # Draw Reeling Meter
        meter_x = SCREEN_WIDTH // 2 - 150
        meter_y = 50
        meter_width = 300
        meter_height = 20
        
        # Background
        pygame.draw.rect(surface, WHITE, (meter_x, meter_y, meter_width, meter_height), 2)
        
        # Player Reel Strength (Red)
        reel_width = int(meter_width * (player.reel_meter / MAX_REEL_STRENGTH))
        reel_color = (255 - player.reel_meter * 2, player.reel_meter * 2, 0) # Green to Red
        pygame.draw.rect(surface, reel_color, (meter_x, meter_y, reel_width, meter_height))
        
        # Tension Line (Visual aid for fish pull)
        tension_indicator = int(meter_width * (1.0 - fish.pull_strength / player.rod_strength))
        pygame.draw.line(surface, BLUE_DARK, 
                         (meter_x + tension_indicator, meter_y), 
                         (meter_x + tension_indicator, meter_y + meter_height), 4)

def draw_instructions(surface, game_state):
    font = pygame.font.Font(None, 30)
    instructions = ""
    if game_state == CASTING:
        instructions = "Click to Cast Bobber!"
    elif game_state == WAITING:
        instructions = "Wait for the Bobber to sink..."
    elif game_state == REELING:
        instructions = "Hold SPACE to Reel! Don't let the red bar hit the end!"

    if instructions:
        text_surface = font.render(instructions, True, WHITE)
        surface.blit(text_surface, (SCREEN_WIDTH // 2 - text_surface.get_width() // 2, SCREEN_HEIGHT - 30))

def draw_fish_popup(surface, fish):
    font = pygame.font.Font(None, 50)
    text = f"CAUGHT! {fish.get_name()} ({fish.size:.1f}cm)! +{fish.points} points"
    text_surface = font.render(text, True, GREEN)
    
    # Center the text
    x = SCREEN_WIDTH // 2 - text_surface.get_width() // 2
    y = SCREEN_HEIGHT // 2 - text_surface.get_height() // 2
    
    # Background box for readability
    bg_rect = text_surface.get_rect(topleft=(x, y))
    bg_rect.inflate_ip(20, 10)
    pygame.draw.rect(surface, BLUE_DARK, bg_rect)
    pygame.draw.rect(surface, GREEN, bg_rect, 3) # Border
    
    surface.blit(text_surface, (x, y))

# --- 4. Main Game Loop ---

def game_loop():
    # Initial setup
    player = Player()
    bobber = Bobber((100, 100))
    current_state = CASTING
    fish = None
    fish_popup_timer = 0
    
    clock = pygame.time.Clock()
    running = True

    while running:
        # Event handling
        keys = pygame.key.get_pressed()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            
            # --- Casting Input ---
            if current_state == CASTING and event.type == pygame.MOUSEBUTTONDOWN:
                if event.button == 1: # Left click
                    target_x = event.pos[0]
                    if target_x > 150: # Must cast away from the player
                        bobber.cast(target_x)
                        current_state = CASTING

            # --- Reeling Input ---
            if current_state == REELING:
                if keys[pygame.K_SPACE]:
                    player.reel_meter = min(MAX_REEL_STRENGTH, player.reel_meter + REEL_SPEED)
                else:
                    player.reel_meter = max(0, player.reel_meter - REEL_SPEED * 0.5)

        # --- Game Logic Update ---
        
        # State: CASTING
        if current_state == CASTING and bobber.is_cast:
            new_state = bobber.update_casting()
            if new_state == WAITING:
                current_state = WAITING

        # State: WAITING
        elif current_state == WAITING:
            bobber.update_waiting()
            # Chance to get a bite (random timer)
            if random.randint(1, 60 * 5) == 1 and fish is None and bobber.y >= bobber.target_y - 1: # ~5 second average wait
                fish = Fish()
                current_state = REELING
                player.reel_meter = MAX_REEL_STRENGTH * 0.5 # Start mid-way
        
        # State: REELING
        elif current_state == REELING:
            # 1. Apply Fish Pull
            pull = fish.get_pull()
            player.reel_meter -= pull
            
            # 2. Check for Fail/Success
            if player.reel_meter <= 0:
                # LINE SNAPPED!
                current_state = CASTING
                fish = None
                print("Line Snapped! Fish got away.")
            elif player.reel_meter >= MAX_REEL_STRENGTH:
                # FISH CAUGHT!
                player.add_score(fish.points)
                fish_popup_timer = 3 * FPS # Show popup for 3 seconds
                current_state = CASTING # Back to casting state
                print(f"Caught a {fish.get_name()} for {fish.points} points!")
                fish = None

        # Handle Popup Timer
        if fish_popup_timer > 0:
            fish_popup_timer -= 1
        
        # --- Drawing ---
        draw_water(screen)
        bobber.draw(screen)
        draw_hud(screen, player, current_state, bobber)
        draw_instructions(screen, current_state)

        if fish_popup_timer > 0 and fish is None:
            # Recreate a dummy fish object just for the popup display before it's cleared
            # In a proper game, you'd store the *last_caught_fish*
            # For simplicity, we'll just not show a popup if the fish object is gone right after catch
            pass # Skipping complex state for now, but a "Last Caught" variable would be better

        # This assumes the fish popup logic needs to be simplified to display *after* the fish is caught
        # Let's add a `last_caught_fish` attribute to Player for a proper popup.
        if fish_popup_timer > 0:
            # Draw the success message and details
            font = pygame.font.Font(None, 50)
            text = f"SUCCESS! +{player.score - (player.score - fish_popup_timer)} points" # Placeholder
            
            # To fix the fish name/points, we need to pass the *details* when the fish is caught, not rely on the `fish` object being there.
            
            # Simplified Popup (You'd need to store the fish details on catch)
            text = f"SUCCESSFUL REEL! +{int(player.score * 0.1)} Points!"
            text_surface = font.render(text, True, GREEN)
            screen.blit(text_surface, (SCREEN_WIDTH // 2 - text_surface.get_width() // 2, SCREEN_HEIGHT // 2))

        # Update display and maintain frame rate
        pygame.display.flip()
        clock.tick(FPS)

    pygame.quit()

# Run the game
# game_loop() # Uncomment this line to run the game
